type List<T> = Cons(T, List<T>) | Nil;

function cons<T>(x: T, xs: List<T>) -> List<T> {
    return Cons(x, xs);
}

function head<T>(xs: List<T>) -> T | null {
    return match xs {
        Cons(h, t) => h,
        Nil => null
    };
}

interaction main() -> Unit {
    let xs: List<Int> = cons(1, cons(2, Nil()));
    // Print head via built-in if available, else just build and run (no Prelude)
    // We'll use a simple check: if head works we expect 1
    let h = head(xs);
    // No println without Prelude - compiler should still build; run and check exit code
}
