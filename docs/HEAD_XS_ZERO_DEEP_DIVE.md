# Deep Dive: Why `head(xs)` Returns 0 for `xs = cons(1, cons(2, cons(3, Nil())))`

## 1. Full chain from source to runtime

### 1.1 Source (main.first)

```first
let xs: List<Int> = cons(1, cons(2, cons(3, Nil())));
// ...
println("head(xs) = " + intToString(head(xs)) + ", ...");
```

- `cons` is the generic function in the same file: `function cons<T>(x: T, xs: List<T>) -> List<T> { return Cons(x, xs); }`
- So we have three calls: outer `cons(1, list23)`, middle `cons(2, list3)`, inner `cons(3, Nil())`.

### 1.2 AST

- Parser builds one `Program` for main.first (no `module` decl → treated as "main").
- The outer call is a `FunctionCallExpr` with:
  - `getName()` = `"cons"`
  - `getArgs()` = `[LiteralExpr(Int, "1"), FunctionCallExpr("cons", [LiteralExpr(2), ...])]`
- So for the **outer** call, the first argument is definitely `LiteralExpr(1)` in the AST.

### 1.3 Compilation flow (Compiler)

1. **Single main IR generator**  
   One `IRGenerator` is created and `generate(ast_.get())` is called for the **main** AST only. So all of main’s code (including `cons(1, cons(2, cons(3, Nil())))` and main’s `cons_Int`) is generated by this one generator.

2. **Imported modules (e.g. Prelude)**  
   After main’s module is generated, for each loaded module (e.g. Prelude) a **new** `IRGenerator` is created and that module’s IR is generated and **linked in** to the main module. Prelude does **not** define `cons` (only interfaces). So there is only one `cons_Int` in the final module: the one from main.

3. **No AST merging**  
   Main’s AST is never merged with Prelude’s. The call `cons(1, cons(2, cons(3, Nil())))` lives only in main’s AST, and that’s the AST we’re walking when we generate the outer `cons` call.

### 1.4 IR generation for the outer `cons(1, ...)`

In `evaluateFunctionCall(expr)` for the outer call:

1. **Argument vector**  
   `argExprs = expr->getArgs()` → `[LiteralExpr(1), cons(2, cons(3, Nil()))]`.

2. **Loop**  
   - `i = 0`: `evaluateExpr(argExprs[0])` → `evaluateExpr(LiteralExpr(1))` → `ConstantInt(1)`.  
   - The “cons first-arg literal” fix: if `isConsCall("cons")` and `getConsFirstArgLiteral(argExprs[0], literalVal)` then we force `argValue = ConstantInt(literalVal)`. So we intend to push `1`.  
   - `i = 1`: we evaluate the inner `cons(2, cons(3, Nil()))` (nested `evaluateFunctionCall`), get back the list value, push it.

3. **After the loop**  
   We have `args = [1, list]` (with the fix). There is also a safety net that again sets `args[0]` from the first argument literal when it’s an Int literal.

4. **Not a constructor**  
   `getConstructorIndex("cons")` is false (constructor is `"Cons"`). So we do **not** take the constructor path; we go to the generic-call path.

5. **Call**  
   We resolve `cons_Int` (monomorphized from main’s `cons`) and emit `call cons_Int(args[0], args[1])` = `cons_Int(1, list)`.

So in the **intended** design we pass `1` as the first argument for the outer call.

### 1.5 Inside `cons_Int`

- Body: `return Cons(x, xs);`
- `x` and `xs` are the LLVM parameters (from the allocas we set up from the function args). So the value of `x` is exactly what was passed as the first argument.
- `return Cons(x, xs)` is compiled as building an ADT: tag + payload. The first payload field is `x`, the second is `xs`. So the **head** stored in memory is the first argument we passed.

### 1.6 When we call `head(xs)`

- `head` is implemented as `match xs { Cons(h, t) => h, Nil => null }`.
- Pattern match loads the same payload layout: first field = `h`, second = `t`.
- So `h` is the value we stored as the first payload field when we built `Cons(x, xs)`.

Conclusion of the chain: **if the first argument to the outer `cons_Int` is 1, then the head we store and then read back is 1. If we see 0, then at runtime we are storing (and therefore passing) 0 as that first argument.**

---

## 2. Why 0 appears

So the only way to get `head(xs) = 0` is:

- The **first argument** passed to the **outer** `cons_Int(1, list)` at the **call site** is **0** (or something that becomes 0 when stored/loaded).

So either:

- The compiler that produced the running binary is **not** applying the “cons first-arg literal” fix (e.g. it’s an older or different `firstc`), or  
- The fix is present but **does not fire** for this call (e.g. `isConsCall` or `getConsFirstArgLiteral` is false for the outer call), or  
- Something **after** we set `args[0] = 1` overwrites it (e.g. argument casting or a different code path). Our review of the cast loop and constructor path suggests we don’t overwrite `args[0]` for the normal `cons_Int(i64, ptr)` case.

---

## 3. Most likely root cause: which `firstc` is used

`fir` chooses the compiler like this:

```bash
find_firstc() {
  if command -v firstc >/dev/null 2>&1; then
    command -v firstc    # ← PATH wins first
    return
  fi
  local build_bin="$PROJECT_ROOT/build/bin/firstc"
  if [[ -x "$build_bin" ]]; then
    echo "$build_bin"
    return
  fi
  echo ""
}
```

So:

- If **any** `firstc` exists on `PATH` (e.g. from a previous `brew install` or another build), **that** binary is used for `fir build`.
- The repo’s `build/bin/firstc` (where our fix lives) is only used when `firstc` is **not** on `PATH`.

So the most likely root cause is:

**The binary that actually compiles `chapter-07-Intro-to-generic-types` is a different `firstc` (from PATH) that does not contain the “cons first-arg literal” fix. The executable is therefore built by an older/different compiler that still passes 0 for the outer `cons(1, ...)` first argument.**

That would explain why the same source and same `fir run` still show `head(xs) = 0` even though the fix is in the repo’s `firstc`.

---

## 4. How to verify

1. **Which firstc is used**
   - From the project directory (e.g. `examples/chapter-07-Intro-to-generic-types`):
     ```bash
     which firstc
     ```
   - Or from repo root:
     ```bash
     ./tools/fir build   # then check which firstc was used
     ```
   - If this prints something like `/usr/local/bin/firstc` or another path **outside** the repo, that compiler is the one building the app.

2. **Force using the repo’s firstc**
   - Prefer the local build over PATH:
     ```bash
     PATH="$(pwd)/build/bin:$PATH" ../../tools/fir build
     ../../tools/fir run
     ```
   - Or from repo root:
     ```bash
     PATH="$PWD/build/bin:$PATH" ./tools/fir build
     ./tools/fir run
     ```
   - If after this `head(xs)` becomes 1, that confirms the root cause was which `firstc` was used.

3. **Inspect generated IR (optional)**
   - Add a way to dump the module to a `.ll` file (e.g. `writeIRToFile`) and build with the **repo** `firstc` (using the PATH override above).
   - Search for the call to `cons_Int` that corresponds to the outer `cons(1, ...)` (e.g. the one that uses the result of the inner `cons(2, cons(3, Nil()))`).
   - Check the first argument of that call: it should be `i64 1`. If it is `i64 0`, then the bug is in the IR generator (fix not firing or being overwritten). If it is `i64 1` but the program still prints 0, the bug would be elsewhere (e.g. layout or linking).

---

## 5. Summary

- **Symptom:** `head(xs) = 0` for `xs = cons(1, cons(2, cons(3, Nil())))`.
- **Data flow:** The head value comes from the first argument passed to the outer `cons_Int` call. If that argument is 0, we get 0.
- **Intended fix:** In the IR generator we force the first argument of `cons` to the Int literal from the AST when the first arg is an Int literal, so we should pass 1.
- **Most likely root cause:** `fir build` is using a `firstc` from **PATH** (an older or different install) instead of the repo’s `build/bin/firstc`, so the executable is not built with the fix.
- **Next step:** Use `PATH=".../build/bin:$PATH" fir build` and then `fir run`; if that fixes the output, then making `fir` prefer the repo’s `firstc` (or documenting the PATH override) is the right resolution. If the bug persists even with the repo’s `firstc`, then the next step is to dump IR and confirm whether the outer `cons_Int` is called with `1` or `0`.
